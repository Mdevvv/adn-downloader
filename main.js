import puppeteer from 'puppeteer';
import os from 'os';
import { spawn  } from 'child_process';
import fs from 'fs';
import readline from 'readline';
import axios from 'axios';

let Nm3u8RE = "N_m3u8DL-RE";

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

function input(question) {
  return new Promise((resolve) => {
    rl.question(question, (reponse) => {
      resolve(reponse);
    });
  });
}

function runNm3u8RE(link, outputFile = 'output') {
  return new Promise((resolve, reject) => {
    const process = spawn(Nm3u8RE, [link, '--auto-select', '--live-pipe-mux', '--save-name', outputFile]);

    process.stdout.on('data', (data) => {
      console.log(`Nm3u8RE stdout: ${data}`);
    });

    process.stderr.on('data', (data) => {
      console.error(`Nm3u8RE stderr: ${data}`);
    });

    process.on('error', (error) => {
      reject(new Error(`Error from Nm3u8RE: ${error.message}`));
    });

    process.on('close', (code) => {
      if (code === 0) {
        resolve('Video Download Successful.');
      } else {
        reject(new Error(`Nm3u8RE exited with exit code: ${code}`));
      }
    });
  });
}


function runFFmpegVF(inputFile, outputFile = 'output.aac') {
  return new Promise((resolve, reject) => {
    const process = spawn('ffmpeg', ['-i', inputFile, '-c:a', 'copy', '-vn', outputFile + '.aac']);

    process.stdout.on('data', (data) => {
      console.log(`ffmpeg stdout: ${data}`);
    });

    process.stderr.on('data', (data) => {
      console.error(`ffmpeg stderr: ${data}`);
    });

    process.on('error', (error) => {
      reject(new Error(`Error from ffmpeg: ${error.message}`));
    });

    process.on('close', (code) => {
      if (code === 0) {
        resolve(`Audio successfully extracted to : ${outputFile}`);
      } else {
        reject(new Error(`ffmpeg exited with exit code: ${code}`));
      }
    });
  });
}


function convertToAss(subs) {
  const assFile = 'output.ass';
  
  const header = `[Script Info]
; Script generated by Aegisub 9215, Daydream Cafe Edition [Shinon]
; http://www.aegisub.org/ 
; Rip Script
; https://github.com/Mdevvv
Title: Français (France)
Original Script: Auteur
Original Translation: 
Original Editing: 
Original Timing: 
Synch Point: 
Script Updated By: 
Update Details: 
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080
Timer: 0.0000
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.709

[Aegisub Project Garbage]
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Trebuchet MS,66,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,3,2,75,75,75,1
Style: Leftbot,Trebuchet MS,66,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,3,1,75,75,75,1
Style: Rightbot,Trebuchet MS,66,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,3,3,75,75,75,1
Style: Leftmid,Trebuchet MS,66,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,3,4,75,75,75,1
Style: Midmid,Trebuchet MS,66,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,3,5,75,75,75,1
Style: Rightmid,Trebuchet MS,66,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,3,6,75,75,75,1
Style: Lefttop,Trebuchet MS,66,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,3,7,75,75,75,1
Style: Midtop,Trebuchet MS,66,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,3,8,75,75,75,1
Style: Righttop,Trebuchet MS,66,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,3,3,9,75,75,75,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`


  function convertTime(seconds_float) {
    const hours = Math.floor(seconds_float / 3600);
    const minutes = Math.floor((seconds_float % 3600) / 60);
    const seconds = Math.floor(seconds_float % 60);
    const milliseconds = Math.floor((seconds_float - Math.floor(seconds_float)) * 100);

    
    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(2, '0')}`;
  }

  function getIndexAlign(curr) {
      const weights = ["start", "middle", "end"];
      const width = weights.indexOf(curr.positionAlign);
      const height = weights.indexOf(curr.lineAlign) * 3;

      return style[width + height];
  }

  function replaceUnicodeSequences(text) {
      
      const unicodePattern = /\\u([0-9a-fA-F]{4})/g;

      function decodeUnicode(match, p1) {
          
          return String.fromCharCode(parseInt(p1, 16));
      }

      
      return text.replace(unicodePattern, decodeUnicode);
  }

  function textRefractor(curr) {
    if (curr && typeof curr.text === 'string') {
      return replaceUnicodeSequences(curr.text)
          .replace(/\n/g, "\\N")
          .replace(/<i>/g, "{\\i1}")
          .replace(/<\/i>/g, "{\\i0}")
          .replace(/<b>/g, "{\\b1}")
          .replace(/<\/b>/g, "{\\b0}")
          .replace(/<u>/g, "{\\u1}")
          .replace(/<\/u>/g, "{\\u0}");
    } else {
        return '';
    }
  }


  const style = [
    "Leftbot", "Default", "Rightbot",
    "Leftmid", "Midmid", "Rightmid",
    "Lefttop", "Midtop", "Righttop"
  ];


  fs.writeFileSync(assFile, header + '\n')

  const data = subs[Object.keys(subs)[0]];
  for (let i = 0; i < data.length; ++i) {
    const curr = data[i];
    fs.appendFileSync(assFile, "Dialogue: 0," + convertTime(curr["startTime"]) + "," + convertTime(curr["endTime"]) + ","+ getIndexAlign(curr) +",,0,0,0,," + textRefractor(curr) + '\n');
  }
}



(async () => {
    const sessionFilePath = './sessionData.json';
    const profileFilePath = './profileData.json';

    const sessionData = JSON.parse(fs.readFileSync(sessionFilePath, 'utf8'));
    const profileData = JSON.parse(fs.readFileSync(profileFilePath, 'utf8'));

    const { accessToken, refreshToken } = sessionData;
    const profile = {
        "id": 1,
        "main": true,
        "name": `${profileData['profiles'][0]["name"]}`,
        "avatar": `${profileData['profiles'][0]["avatar"]}`,
        "ageCategory": null
    };

  
  
  const infoURL = 'https://gw.api.animationdigitalnetwork.fr/video/'
  const URL = 'https://animationdigitalnetwork.com';
  const url = await input('url : ');
  
  rl.close();

  const regex = /\/video\/(\d+)-(?:[^\/]+)\/(\d+)-/;

  const match = url.match(regex);
  let workId = ''
  let episodeId = ''
  if (match && match[1] && match[2]) {
    workId = match[1];
    episodeId = match[2];
    console.log('Work ID:', workId);
    console.log('Episode ID:', episodeId);
  } else {
    console.log('No IDs found');
  }

  const loginHeaders = {
    'Content-Type': 'application/json',
    'X-Target-Distribution': 'fr',
    'X-I18n-Platform': '1',
    'Origin': URL,
    'Referer': URL,
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.112 Safari/537.36',
    'Accept': 'application/json'
  };

  const infoResponce = await axios.get(infoURL+episodeId,{ headers: loginHeaders })

  const infoJsonData = infoResponce.data;

  let launchOptions = { headless: "shell", args: ['--no-sandbox', '--disable-setuid-sandbox'] }; // Paramètre par défaut (headless)

  const isVF = infoJsonData["video"]["languages"].length > 1;

  console.log('Is Video Format: ', isVF);

  if (os.platform() === 'linux') {
    launchOptions.executablePath = '/usr/bin/chromium';
    Nm3u8RE = "n-m3u8dl-re";
  }

  const browser = await puppeteer.launch(launchOptions);
  const page = await browser.newPage();

  await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.119 Safari/537.36');
  
  await page.setRequestInterception(true);

  let m3u8Urls = null;
  let logged = false;

  page.on('request', async request => {
    const url = request.url();

    if(logged && url === url) {
        logged = true;
        request.continue();
    }
    else if (url.includes('adn-vjs') && url.includes('.js')) {
      console.log('including load:', url);
      const response = await fetch(url);
      let resp = await response.text();
      resp = resp.replace("P[this.trackIndex]=JSON.parse(r)||{}", "P[this.trackIndex]=JSON.parse(r)||{}; window.exposedValue = P[this.trackIndex];");
        

      request.respond({
        status: 200,
        contentType: 'application/javascript',
        body: `${resp}`
      });
    } else if (url.includes('playlist.m3u8')) {
      m3u8Urls = url;
      request.continue();
    } else {
      request.continue();
    }
  });

  
  await page.goto(url);

  await page.evaluateOnNewDocument(({ accessToken, refreshToken, profile }) => {
    localStorage.setItem('token', accessToken);
    localStorage.setItem('refresh_token', refreshToken);
    localStorage.setItem('profile', JSON.stringify(profile));
    logged = true;
  }, { accessToken, refreshToken, profile });
  

  await page.goto(url, {waitUntil: 'networkidle2'});
  
  const PValue = await page.evaluate(() => {
    return window.exposedValue;
  });

  console.log('m3u8 URL:', m3u8Urls);
  console.log('PValue:', PValue);
  await browser.close();

  try {
    
    const tasks = [];

    if (m3u8Urls && false) {
      if(isVF) {
          tasks.push(new Promise((resolve) => {
            runNm3u8RE(m3u8Urls.replace("playlist.m3u8?", "playlist.m3u8?audioindex=0&"));
            resolve();
          }));

          tasks.push(new Promise((resolve) => {
            runFFmpegVF(m3u8Urls.replace("playlist.m3u8?", "playlist.m3u8?audioindex=1&"), "output.vf");
            resolve();
          }));
      } else {
        tasks.push(new Promise((resolve) => {
          runNm3u8RE(m3u8Urls);
          resolve();
        }));
      }
    }
    if(m3u8Urls && PValue) {
      console.log('Converting to ASS...');
      tasks.push(new Promise((resolve) => {
        convertToAss(PValue);
        resolve();
      }));
    }
    await Promise.all(tasks);
  } catch (err) {
    console.error('Rip error:', err.message);
  }  
})();